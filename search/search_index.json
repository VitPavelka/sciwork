{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SciWork","text":"<p>A collection of small, focused libraries for scientific workflows.</p> <ul> <li>Robust Config\u2014robust INI loader with layering, typing, env/CLI overrides, and JSON-schema (template) validation.</li> </ul>"},{"location":"robust-config/","title":"Robust Configs","text":"<p>Robust INI configuration loader with:</p> <ul> <li>Multiple file layering (base \u2192 env \u2192 CLI \u2192 in-memory)</li> <li>Section inheritance via <code>extends</code></li> <li>Type-safe parsing (bool/int/float/None, lists, JSON-like)</li> <li>Env (<code>CONF__SECTION__KEY</code>) and CLI overrides</li> <li>Optional JSON template schema with defaults and validators</li> <li>Helpful errors + tiny CLI</li> </ul>"},{"location":"robust-config/api/","title":"API Reference","text":"<p>Robust INI configuration loader with layering, typing, and validation.</p> <p>This class wraps :class: 'configparser.ConfigParser' and projects values into typed Python objects. It also supports optional inheritance between sections and future schema validation.</p> <p>Initialize an empty configuration holder.</p> <p>Parameters:</p> Name Type Description Default <code>env_prefix</code> <code>str</code> <p>Prefix for environment variable overrides (e.g., \"CONF__SECTION__KEY\"). Currently, stored only; the application of env overrides lives in a later method.</p> <code>'CONF'</code> <code>csv_delimiters</code> <code>Optional[str]</code> <p>If \"None\" (default), do not split plain strings into lists. If a string of delimiter characters (e.g., \",;    \"), plain strings containing any of these characters will be split into lists after literal parsing succeeds or when literal parsing is not applicable.</p> <code>None</code> <code>interpolation</code> <code>str</code> <p>\"extended\" (default) to enable ${...} style interpolation, or \"none\" to disable interpolation (treat '$' as a literal).</p> <code>'extended'</code> Source code in <code>src\\robust_config\\core.py</code> <pre><code>def __init__(\n\t\tself,\n\t\t*,\n\t\tenv_prefix: str = \"CONF\",\n\t\tcsv_delimiters: Optional[str] = None,\n\t\tinterpolation: str = \"extended\",  # \"extended or \"none\"\n) -&gt; None:\n\t\"\"\"\n\tInitialize an empty configuration holder.\n\n\t:param env_prefix: Prefix for environment variable overrides (e.g.,\n\t\t\t\t\t\t\"CONF__SECTION__KEY\"). Currently, stored only; the\n\t\t\t\t\t\tapplication of env overrides lives in a later method.\n\t:param csv_delimiters: If \"None\" (default), do **not** split plain strings\n\t\t\t\t\t\t\tinto lists. If a string of delimiter characters\n\t\t\t\t\t\t\t(e.g., \",;    \"), plain strings containing any\n\t\t\t\t\t\t\tof these characters will be split into lists\n\t\t\t\t\t\t\t**after** literal parsing succeeds or when\n\t\t\t\t\t\t\tliteral parsing is not applicable.\n\t:param interpolation: \"extended\" (default) to enable ${...} style\n\t\t\t\t\t\t\tinterpolation, or \"none\" to disable interpolation\n\t\t\t\t\t\t\t(treat '$' as a literal).\n\t\"\"\"\n\tinterp = configparser.ExtendedInterpolation() if \\\n\t\tstr(interpolation).lower() in {\"none\", \"no\", \"off\", \"false\", \"f\", \"raw\"} else None\n\tself._config = configparser.ConfigParser(interpolation=interp)\n\tself._loaded_files: List[Path] = []\n\tself._data: Dict[str, Dict[str, Any]] = {}\n\tself.env_prefix = env_prefix\n\tself.csv_delimiters = csv_delimiters\n\tself.interpolation = \"none\" if interp is None else \"extended\"\n\tself._schema_defaults: Dict[str, Dict[str, Any]] = {}\n</code></pre>"},{"location":"robust-config/api/#robust_config.RobustConfig.load","title":"<code>load(files)</code>","text":"<p>Load one or more INI files; later files override earlier ones.</p> <p>Paths are read in the given order. After loading, values are projected into a nested \"dict\" with typed values and section inheritance is resolved.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Iterable[Union[str, PathLike]]</code> <p>Iterable of filesystem paths (\"str\" or \"PathLike\").</p> required <p>Returns:</p> Type Description <code>'RobustConfig'</code> <p>The \"self\" for fluent chaining.</p> <p>Raises:</p> Type Description <code>ConfigError</code> <p>If any file is missing or cannot be read.</p> Source code in <code>src\\robust_config\\core.py</code> <pre><code>def load(self, files: Iterable[Union[str, os.PathLike]]) -&gt; \"RobustConfig\":\n\t\"\"\"\n\tLoad one or more INI files; later files override earlier ones.\n\n\tPaths are read in the given order. After loading, values are projected\n\tinto a nested \"dict\" with typed values and section inheritance is resolved.\n\n\t:param files: Iterable of filesystem paths (\"str\" or \"PathLike\").\n\t:return: The \"self\" for fluent chaining.\n\t:raises ConfigError: If any file is missing or cannot be read.\n\t\"\"\"\n\tLOG.info(\"Loading INI files: %s\", \",\".join(str(Path(p)) for p in files))\n\n\tpaths = [Path(p) for p in files]\n\tmissing = [str(p) for p in paths if not p.exists()]\n\tif missing:\n\t\traise ConfigError(f\"Missing config file(s): {', '.join(missing)}\")\n\n\tfor path in paths:\n\t\ttry:\n\t\t\twith path.open(\"r\", encoding=\"utf-8\") as file_handle:\n\t\t\t\tself._config.read_file(file_handle)\n\t\t\tself._loaded_files.append(path)\n\t\t\tLOG.info(\"Loaded INI file: %s\", path)\n\t\texcept Exception as exc:\n\t\t\traise ConfigError(f\"Failed reading '{path}': {exc}\") from exc\n\n\t# Project into typed dict now; allows overrides/validation downstream\n\tself._data = self._project_configparser_to_dict(self._config)\n\tself._resolve_inheritance()\n\tLOG.info(\"Resolved sections after inheritance: %s\", \", \".join(sorted(self._data.keys())))\n\treturn self\n</code></pre>"},{"location":"robust-config/api/#robust_config.RobustConfig.apply_env_overrides","title":"<code>apply_env_overrides()</code>","text":"<p>Apply overrides from environment variables.</p> <p>Pattern: \"&lt;&gt;____KEY=VALUE\" (case-insensitive for section/key). The value is parsed via :meth: '_parse_value'. <p>Example with the default prefix \"CONF\":</p> <pre><code>    export CONF__MAIN__HEADER_ROWS=0\n    export CONF__MAIN__GENERAL_KEYWORDS='[\"_\", \"extra\"]'\n</code></pre> <p>Returns:</p> Type Description <code>'RobustConfig'</code> <p>The \"self\" for fluent chaining.</p> Source code in <code>src\\robust_config\\core.py</code> <pre><code>def apply_env_overrides(self) -&gt; \"RobustConfig\":\n\t\"\"\"\n\tApply overrides from environment variables.\n\n\tPattern: \"&lt;&lt;ENV_PREFIX&gt;&gt;__&lt;SECTION&gt;__KEY=VALUE\" (case-insensitive for\n\tsection/key). The value is parsed via :meth: '_parse_value'.\n\n\tExample with the default prefix \"CONF\":\n\n\t\texport CONF__MAIN__HEADER_ROWS=0\n\t\texport CONF__MAIN__GENERAL_KEYWORDS='[\"_\", \"extra\"]'\n\n\t:return: The \"self\" for fluent chaining.\n\t\"\"\"\n\tprefix = f\"{self.env_prefix}__\"\n\tfor env_key, raw_value in os.environ.items():\n\t\tif not env_key.startswith(prefix):\n\t\t\tcontinue\n\t\tremainder = env_key[len(prefix):]\n\t\ttry:\n\t\t\tsection_name, key_name = remainder.split(\"__\", 1)\n\t\texcept ValueError:\n\t\t\tLOG.warning(\"Ignoring malformed env var override '%s' (expected PREFIX__SECTION__KEY)\", env_key)\n\t\t\tcontinue\n\t\tsection_name = section_name.lower()\n\t\tkey_name = key_name.lower()\n\t\tvalue = self._parse_value(raw_value)\n\t\tif section_name not in self._data:\n\t\t\tself._data[section_name] = {}\n\t\tself._data[section_name][key_name] = value\n\t\tLOG.debug(\"env override: %s.%s=%r\", section_name, key_name, value)\n\t\tLOG.info(\"Applied ENV overrides with prefix '%s'\", self.env_prefix)\n\treturn self\n</code></pre>"},{"location":"robust-config/api/#robust_config.RobustConfig.validate","title":"<code>validate(*, schema)</code>","text":"<p>Validate presence and types of keys according to a schema.</p> <p>For each section defined in \"schema\" the method checks:         * if \"required\" keys are present,         * whether the value is an instance of the expected_types,         * and runs the optional \"validator\".</p> <p>All problems are accumulated and reported together for better UX.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Mapping[str, Mapping[str, KeySpec]]</code> <p>Mapping of section name \u2192 mapping of the key \u2192 :class: \"KeySpec\".</p> required <p>Returns:</p> Type Description <code>'RobustConfig'</code> <p>The \"self\" (useful for fluent chaining).</p> <p>Raises:</p> Type Description <code>ConfigError</code> <p>If any validation error occurs.</p> Source code in <code>src\\robust_config\\core.py</code> <pre><code>def validate(self, *, schema: Mapping[str, Mapping[str, KeySpec]]) -&gt; \"RobustConfig\":\n\t\"\"\"\n\tValidate presence and types of keys according to a schema.\n\n\tFor each section defined in \"schema\" the method checks:\n\t\t* if \"required\" keys are present,\n\t\t* whether the value is an instance of the expected_types,\n\t\t* and runs the optional \"validator\".\n\n\tAll problems are accumulated and reported together for better UX.\n\n\t:param schema: Mapping of section name \u2192 mapping of the key \u2192 :class: \"KeySpec\".\n\t:return: The \"self\" (useful for fluent chaining).\n\t:raises ConfigError: If any validation error occurs.\n\t\"\"\"\n\t# Apply defaults (if any) before performing validations\n\tself._schema_apply_defaults()\n\n\terrors: List[str] = []\n\tfor section_name, key_specs in (schema or {}).items():\n\t\tvalues = self._data.get(section_name, {})\n\t\tfor key_name, spec in key_specs.items():\n\t\t\tif spec.required and key_name not in values:\n\t\t\t\terrors.append(f\"[{section_name}] missing required key '{key_name}'\")\n\t\t\t\tcontinue\n\t\t\tif key_name not in values:\n\t\t\t\tcontinue\n\n\t\t\tval = values[key_name]\n\t\t\tif not isinstance(val, spec.expected_type):\n\t\t\t\terrors.append(\n\t\t\t\t\tf\"[{section_name}] key '{key_name}' expected {spec.expected_type}, \"\n\t\t\t\t\tf\"got {type(val)} ({val!r})\"\n\t\t\t\t)\n\n\t\t\tvalidator_fn = getattr(spec, \"validator\", None)\n\t\t\tif validator_fn is not None:\n\t\t\t\tif not callable(validator_fn):\n\t\t\t\t\terrors.append(\n\t\t\t\t\t\tf\"[{section_name}] key '{key_name}' has a non-callable validator \"\n\t\t\t\t\t\tf\"of type {type(validator_fn)}: {validator_fn}\"\n\t\t\t\t\t)\n\t\t\t\telse:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tvalidator_fn(val)\n\t\t\t\t\texcept Exception as exc:\n\t\t\t\t\t\terrors.append(f\"[{section_name}] key '{key_name}' validation failed: {exc}\")\n\tif errors:\n\t\thint = (\n\t\t\t\"Use --dump pretty to inspect values; overrides can be applied via \"\n\t\t\t\"env (CONF__SEC__KEY) or CLI --override SEC.key=val.\"\n\t\t)\n\t\traise ConfigError(\"\\n\".join(errors) + \"\\n\\n\" + hint)\n\treturn self\n</code></pre>"},{"location":"robust-config/api/#robust_config.RobustConfig.load_schema_from_json","title":"<code>load_schema_from_json(schema_path, *, template, project=None, sections=None)</code>","text":"<p>Load a template schema (e.g. 'data_handler') and apply it to many sections.</p> <p>Accepted shapes:         1) Direct sections:                 {                         \"section\": {                                 \"key\": {                                         \"type\": \"str|int|list[str]|...\", \"required\": true,                                         \"choices\": [...], \"default\":                                  }                         }                 }         2) Projected:                 { \"projects\": { \"\": { ... same as (1)... } } } <p>Defaults (if present) are stored and applied at validate-time.</p> <p>Parameters:</p> Name Type Description Default <code>schema_path</code> <code>Union[str, PathLike]</code> <p>Path to a JSON schema file.</p> required <code>template</code> <code>str</code> <p>Template name to use (e.g., \"data_handler\").</p> required <code>project</code> <code>Optional[str]</code> <p>Optional project when using the 'projects' wrapper.</p> <code>None</code> <code>sections</code> <code>Optional[List[str]]</code> <p>Which sections to apply to; defaults to all current sections.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[str, Mapping[str, KeySpec]]</code> <p>Per-section schema mapping built from the template.</p> <p>Raises:</p> Type Description <code>ConfigError</code> <p>On IO/parse errors or shape errors.</p> Source code in <code>src\\robust_config\\core.py</code> <pre><code>def load_schema_from_json(\n\t\tself,\n\t\tschema_path: Union[str, os.PathLike],\n\t\t*,\n\t\ttemplate: str,\n\t\tproject: Optional[str] = None,\n\t\tsections: Optional[List[str]] = None,\n) -&gt; Mapping[str, Mapping[str, KeySpec]]:\n\t\"\"\"\n\tLoad a *template* schema (e.g. 'data_handler') and apply it to many sections.\n\n\tAccepted shapes:\n\t\t1) Direct sections:\n\t\t\t{\n\t\t\t\t\"section\": {\n\t\t\t\t\t\"key\": {\n\t\t\t\t\t\t\"type\": \"str|int|list[str]|...\", \"required\": true,\n\t\t\t\t\t\t\"choices\": [...], \"default\": &lt;any&gt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t2) Projected:\n\t\t\t{ \"projects\": { \"&lt;project_name&gt;\": { ... same as (1)... } } }\n\n\tDefaults (if present) are stored and applied at validate-time.\n\n\t:param schema_path: Path to a JSON schema file.\n\t:param template: Template name to use (e.g., \"data_handler\").\n\t:param project: Optional project when using the 'projects' wrapper.\n\t:param sections: Which sections to apply to; defaults to *all* current sections.\n\t:return: Per-section schema mapping built from the template.\n\t:raises ConfigError: On IO/parse errors or shape errors.\n\t\"\"\"\n\traw = self._read_json_object(schema_path, \"schema JSON\")\n\t# support optional projects wrapper\n\troot = raw.get(\"projects\", {}).get(project, raw) if \"projects\" in raw and project else raw\n\tif not isinstance(root, dict):\n\t\traise ConfigError(\"Schema root must be a JSON object.\")\n\n\ttemplate_spec = root.get(template)\n\tif not isinstance(template_spec, dict):\n\t\traise ConfigError(f\"Template '{template}' not found or not an object in schema.\")\n\n\ttarget_sections = sections or list(self._data.keys())\n\tfabricated_root = {sec: template_spec for sec in target_sections}\n\n\tschema, defaults = self._schema_parse_to_keyspecs(fabricated_root)\n\tself._schema_defaults = defaults  # keep for later application\n\treturn schema\n</code></pre> <p>Specification for a configuration key used during validation.</p> <p>Parameters:</p> Name Type Description Default <code>expected_type</code> <code>Union[type, Tuple[type, ...]]</code> <p>Allowed type (or tuple of types) for the key value.</p> required <code>required</code> <code>bool</code> <p>Whether the key must be present.</p> <code>False</code> <code>validator</code> <code>Optional[Validator]</code> <p>Optional callable that receives the parsed value and raises on invalid value.</p> <code>None</code> <p>               Bases: <code>Exception</code></p> <p>Custom exception for configuration-related errors.</p> <p>Keep it simple for now; later it should be extended to carry context like section/key/file and human-friendly hint.</p>"},{"location":"robust-config/api/#robust_config.RobustConfig.section","title":"<code>section(name)</code>","text":"<p>Get a copy of a section dict.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Section name (case-insensitive).</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Copy of the section mapping (key \u2192 typed value).</p> <p>Raises:</p> Type Description <code>ConfigError</code> <p>If the section does not exist.</p> Source code in <code>src\\robust_config\\core.py</code> <pre><code>def section(self, name: str) -&gt; Dict[str, Any]:\n\t\"\"\"\n\tGet a *copy* of a section dict.\n\n\t:param name: Section name (case-insensitive).\n\t:return: Copy of the section mapping (key \u2192 typed value).\n\t:raises ConfigError: If the section does not exist.\n\t\"\"\"\n\tsection_key = name.lower()\n\tif section_key not in self._data:\n\t\tavailable = \", \".join(sorted(self._data)) or \"&lt;none&gt;\"\n\t\traise ConfigError(\n\t\t\tf\"Section '{name}' not found. Available sections: {available}\"\n\t\t)\n\t# Return a shallow copy so callers cannot mutate internal state by accident\n\treturn dict(self._data[section_key])\n</code></pre>"},{"location":"robust-config/api/#robust_config.RobustConfig.sections","title":"<code>sections()</code>","text":"<p>Return a sorted list of section names.</p> Source code in <code>src\\robust_config\\core.py</code> <pre><code>def sections(self) -&gt; List[str]:\n\t\"\"\"Return a sorted list of section names.\"\"\"\n\treturn sorted(self._data.keys())\n</code></pre>"},{"location":"robust-config/api/#robust_config.RobustConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Return a deep-ish copy of the internal data structure.</p> <p>Both the outer and inner dictionaries are copied to prevent accidental mutation of internal state by the caller.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>The \"dict\" of sections with per-key typed values.</p> Source code in <code>src\\robust_config\\core.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Dict[str, Any]]:\n\t\"\"\"\n\tReturn a deep-ish copy of the internal data structure.\n\n\tBoth the outer and inner dictionaries are copied to prevent accidental\n\tmutation of internal state by the caller.\n\n\t:return: The \"dict\" of sections with per-key typed values.\n\t\"\"\"\n\treturn {section: dict(values) for section, values in self._data.items()}\n</code></pre>"},{"location":"robust-config/api/#robust_config.RobustConfig.dump","title":"<code>dump(fmt='pretty', sections=None)</code>","text":"<p>Serialize the configuration to a string for display or export.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>Output format - \"pretty\" (default) or \"json\".</p> <code>'pretty'</code> <code>sections</code> <code>Optional[List[str]]</code> <p>Optional list of section names to include; if omitted, all sections are included.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>String with the rendered configuration.</p> <p>Raises:</p> Type Description <code>ConfigError</code> <p>If an unsupported format is requested.</p> Source code in <code>src\\robust_config\\core.py</code> <pre><code>def dump(self, fmt: str = \"pretty\", sections: Optional[List[str]] = None) -&gt; str:\n\t\"\"\"\n\tSerialize the configuration to a string for display or export.\n\n\t:param fmt: Output format - \"pretty\" (default) or \"json\".\n\t:param sections: Optional list of section names to include; if omitted,\n\t\t\t\t\t\tall sections are included.\n\t:return: String with the rendered configuration.\n\t:raises ConfigError: If an unsupported format is requested.\n\t\"\"\"\n\tdata = self.to_dict()\n\tif sections:\n\t\twanted = {s.lower() for s in sections}\n\t\tdata = {name: values for name, values in data.items() if name in wanted}\n\tif fmt == \"json\":\n\t\treturn json.dumps(data, indent=2, ensure_ascii=False)\n\tif fmt == \"pretty\":\n\t\treturn self._format_pretty(data)\n\traise ConfigError(\"Unsupported dump format. Use 'pretty' or 'json'.\")\n</code></pre>"},{"location":"robust-config/cli/","title":"CLI","text":"<pre><code>robust-config -c inifile.ini --list-sections\nrobust-config -c inifile.ini --sections section --dump pretty\nrobust-config -c inifile.ini --interpolation none --validate \\\n    --schema-json schema.json --schema-template template\n\n## Overrides:\nEnv: CONF__SECTION__KEYWORD=0\nCLI: -o section.keyword=None -o section.keyword2=\"['x','y']\"\n</code></pre>"},{"location":"robust-config/installation/","title":"Installation","text":"<pre><code># From source (editable)\ngit clone https://github.com/VitPavelka/sciwork.git\ncd sciwork\npip install -e .[docs]\n\n# From GitHub (non-editable)\npip install \"git+https://github.com/VitPavelka/sciwork.git\"\n\n# Then\nfrom robust_config import RobustConfig, KeySpec\n\n# And the CLI is available as:\nrobust-config --help\n</code></pre>"},{"location":"robust-config/schema/","title":"JSON Template Schema","text":"<p>Minimal example (applied to all sections):</p> <pre><code>{\n  \"data_handler\": {\n    \"data_folderpath\":      { \"type\": \"str\",                \"required\": true },\n    \"general_keywords\":     { \"type\": [\"list[str]\",\"str\"],  \"default\": [] },\n    \"general_antikeywords\": { \"type\": [\"list[str]\",\"str\"],  \"default\": [] },\n    \"header_rows\":          { \"type\": [\"int\",\"null\"],       \"default\": null },\n    \"sheet_names\":          { \"type\": [\"list[str]\",\"str\",\"null\"], \"default\": null }\n  }\n}\n</code></pre> <pre><code># RUN\nrobust-config -c inifile.ini --validate\n    --schema-json schema.json --schema-template data_handler\n</code></pre>"},{"location":"robust-config/usage/","title":"Usage (Library)","text":"<pre><code>from robust_config import RobustConfig, KeySpec\n\nrc = (RobustConfig()\n    .load([\"inifile.ini\"])\n    .apply_env_overrides()\n    .apply_overrides([]))\n\nmain = rc.section(\"section\")\nprint(main[\"keyword\"])\n\n## Validation with JSON template\nschema = rc.load_schema_from_json(\n    \"schema.json\",\n    template=\"template\", # apply to all sections (or pass sections=[...])\n    project=None\n)\nrc.validate(schema=schema)\n</code></pre>"}]}